use rdkafka::consumer::stream_consumer::StreamConsumer;
use byteorder::{BigEndian, ReadBytesExt};
use futures::StreamExt;
use std::io::{BufRead, Cursor, Error};
use std::str;
use rdkafka::consumer::{Consumer};
use rdkafka::message::{Message};
mod config_reader;

#[derive(Debug)]
struct OffsetCommit {
        group: String,
        topic: String,
        partition: i32,
        offset: i64,
}

pub fn read_str<'a>(rdr: &'a mut Cursor<&[u8]>) -> Result<&'a str, Error> {
    let len = (rdr.read_i16::<BigEndian>()).expect("Error") as usize;
    let pos = rdr.position() as usize;
    let slice = str::from_utf8(&rdr.get_ref()[pos..(pos + len)]).expect("bla");
    rdr.consume(len);
    Ok(slice)
}

pub fn read_string(rdr: &mut Cursor<&[u8]>) -> Result<String,  Error> {
    read_str(rdr).map(str::to_string)
}

fn parse_group_offset(key_rdr: &mut Cursor<&[u8]>,
                      payload_rdr: &mut Cursor<&[u8]>,) {
    let group = read_string(key_rdr).expect("bla");
    let topic = read_string(key_rdr).expect("ble");
    let partition = key_rdr.read_i32::<BigEndian>().expect("bli");
    if !payload_rdr.get_ref().is_empty() {
        let offset = payload_rdr.read_i64::<BigEndian>().expect("blu");
        println!("DATA {:?}, {:?}, {:?}, {:?}", group, topic, partition, offset);
    }
}

#[tokio::main]
async fn main() {
    let config = config_reader::read_config();
    let consumer: StreamConsumer = config.0.create().unwrap();
    consumer.subscribe(&["__consumer_offsets"]).expect("Can't subscribe to specified topic");
    let mut message_stream = consumer.start();
    while let Some(message) = message_stream.next().await {
        match message {
            Ok(Ok(m)) => {
            let key = m.key().unwrap_or(&[]);
            let payload = m.payload().unwrap_or(&[]);
            Ok(Ok(m) => {

                let mut key_rdr = Cursor::new(key);
                let mut payload_rdr = Cursor::new(payload);
                parse_group_offset(& mut key_rdr, & mut payload_rdr)
            },
            Ok(_) => {},
            Err(e) => format_error_chain!(e),
            };
        }
    }
}